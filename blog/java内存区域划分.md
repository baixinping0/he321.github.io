java虚拟机在执行程序时候，会将他所管理的内存区域划分为不同的区域，每个区域都会有各自的用途，最为一名java程序员，深入的理解java虚拟机对其所管理的内存区域的划分，将更好的帮助我们理解java程序的执行过程。以下的讲解均以Hotspot虚拟机进行讲解。
java虚拟机将其管理的内存区域主要划分为程序计数器、java虚拟机栈、本地方法栈、java堆、方法区、运行时常量池六个区域。

###程序计数器
程序计数器是内存中较小的一块区域，可以看做是当前线程所执行字节码的行号指示器，在虚拟机解释器执行字节码文件的过程中，通过改变程序计数器的值来确定下一条将要执行的程序。
程序计数器也是线程私有内存，在多线程的情况下，每个线程都有属于自己的程序计数器，用于记住当前线程所执行的行号。
如果当前执行的不是java方法(Native方法)，计数器的值为null。

程序计数器是唯一一个jvm规范中没有规定OutOfMemoryError的区域。

###java虚拟机栈
java程序中的每个方法执行之前，会创建一个栈帧(用户存储局部变量表，操作数栈，动态链接，方法出口等信息)，然后将栈帧入栈，方法执行结束后，将栈帧出栈。此区域也属于线程私有的。
局部变量表就是用于存储8中基本数据类型以及对象的引用。long和double为64位，需要占用两个局部变量表空间，其余类型数据只占用1个变量表空间。并且在程序编译的过程中每个方法将会分配多大的局部变量表空间已经被确定，程序运行期间不会改变。

如果线程请求的栈深度大于jvm所允许的栈深度，就会抛出StackOverflowError异常。如果java虚拟机栈在动态扩展的时候无法申请足够的空间，就会抛出OutOfMemoryError异常。

###本地方法栈
本地方法栈和java虚拟机栈的功能基本相似，两者间的区别就是java虚拟机栈为java虚拟机执行java方法服务，本地方法栈为虚拟机执行Native方法时服务。

本地方法栈和java虚拟机栈相同，会抛出StackOverflowError异常和OutOfMemoryError异常。

###java堆
java堆属于java内存中最大的一块区域，属于线程共享的。此区域的作用就是为了存放对象以及数组实例，所以是垃圾回收器管理的主要区域。java堆还可以细分为：新生代和老年代，新生代又可以划分为Eden空间，From Survivor空间，To Survivor空间。还可以划分出多个线程私有分配缓冲区（TBAL）。至于细分将会在下一章节中详细讲解。
java堆可以是处于物理上不连续的内存空间，只要逻辑上连续即可。当堆无法进行扩展时，会抛出OutOfMemoryError异常。
###方法区
方法区属于线程共享的区域，用于存储被java虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。由于虚拟机开发者使用永久代来实现方法区，会很容易导致内存移除的问题，所以在jdk1.7中已经将放置在方法区中的字符串常量池移出，在1.8中，已经将方法去完全移至本地。当方法去无法满足内存申请需求的时候会抛出OutOfMemoryError异常。                                                                                                                                                                                                                                                                    
###运行时常量池
运行时常量池属于方法区的一部分，用于存放编译时生成的各种字面量和符号引用，在程序运行期间产生的常量也会放入池中(String.intern())。运行时常量池相对于class文件常量池的另一个重要的特征是具备动态性。当常量池无法申请到足够的内存空间时候会抛出OutOfMemoryError异常。